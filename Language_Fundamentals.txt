1. Identifiers
2. Reserved Words
3. Data Types
4. Literals
5. Arrays
6. Type of Variables
7. var-arg methods
8. main methods
9. command line arguments
10. Java coding standards
===============================================================================================


1. Identifiers
-----------------
A name in Java program is called as identifier which can be used for identification purpose. It can be method name or variable name or class name or label name.
Ex:
class Test{
    public static void main(String []args){
        int x = 10;
    }
}

Number of identifiers are 5 :
Test
main
String (because it is name of predefined class)
args
x

Rules for defining Java Identifiers
--------------------------------------
1. The only allowed characters in Java Identifiers are:
a-z
A-Z
0-9
$
_ (underscore)

If we are using any other character we will get compile time error.

ex:
total_number is a valid identifier
total# is not valid identifier and we will get compile time error.

2. Identifiers cannot start with digits.
ex:
total123 is valid
123total is invalid.

3. Java identifiers are case sensitive. Java language itself is case sensitive.

class Test{
    int number = 10;
    int Number = 20;
    int NUMBER = 30;
}
all above are valid identifiers and are different.

4. There is no length limit for java identifiers but it is not recommended to take too lengthy identifiers.
5. We cannot use reserved words as identifiers.
ex:

int x = 10 is valid
int if = 20 is invalid
6. All predefined java class names and interface names, we can use as identifiers.
Ex:

class Test{
    public static void main(String[] args){
        int String = 9;
        System.out.println(String);
        int Runnable = 10;
        System.out.println(Runnable)
    }
}

Above program is valid,op will be:
9
10

Even though above program is valid, but it is not a good programming practice because it reduces readability and creates confusion.

Q. Which of the following are valid java identifiers?
total_number
total#
123total
total123
ca$h
_$_$_$_$_$
all@hands
java2share
Integer
Int
int

Ans:
total_number, total123, ca$h, _$_$_$_$_$, all@hands, java2share, Integer, Int are valid identifiers

----------------------------------------------------------------------------------------------------------------------------------------------------------

===============================================================================================

2. Reserved Words
-----------------------------------------------------------------------------------

In Java, some words are reserved to represent some meaning and functionality, such types of words are called reserved words.

There are 53 reserved words.
Reserved Keywords: 50
Reserved Literal: 3

Reserved Literals are: true, false, null

In reserved keywords, we have 48 used keywords and unused keywords are 2
Unused keywords - goto, const

Keywords for data types: (8)
----------------------------
byte
short
int
long
float
double
boolean
char

Keywords for flow control: (11)
-----------------------------
if
else
switch
case
default
while
do
for
break
continue
return

Keywords for modifiers: (11)
-------------------------
nothing for default
public
private
protected
static
final
abstract
native
synchronized
strictfp
transient
volatile

Keywords for exception handling (6):
-----------------------------------
try
catch
finally
throw
throws
assert

Class related keywords (6):
-------------------------
class
interface
extends
implements
package
import


Object related keywords (4):
----------------------------
new
instanceof
super
this

Return type keywords (1):
------------------------
void

In Java, return type is mandatory. If a method wont return anything, then we have to declare that method with void return type.
But in C language, return type is optional and default type return type is int.

Unused Keywords (2):
---------------------
goto, const

goto: Usage of goto created several problems in old languages and hence Sun banned this keyword in java
const: Use final instead of const.
NOTE: goto and const are unused keywords and if we are trying to use we will get compile time error.

Reserved literal (3):
----------------------
true, false: value for boolean data types
null: default value for object reference

enum keyword
------------
We can use enum to define a group of named constants.
ex:
enum Month {
    JAN, FEB,... DEC;
}
enum Beer {
    KF, KO, RC;
}

Conclusion:

1. All 53 keywords in java contains only lower case alphabet symbols.
2. new keyword is present in Java, but delete keyword is not present. This is because deletion of objects is responsibility of GarbageCollector.
3.
strictfp but not strictFp
instanceof but not instanceOf
synchronized but not synchronize
extends but not extend
implements but not implement
import but not imports
const but not constant

Q. Which of the following list contains only java reserved words?
1. new, delete
2. goto, constant
3. break, continue, return, exit
4. final, finally, finalize
5. throw, throws, thrown
6. notify, notifyAll
7. implements, extends, imports
8. sizeof, instanceof
9. instanceOf, strictFp
10. byte, short, Int
11. None of the above

Ans:
None of the above.

Q. Which of the following are java reserved words?
public
static
void
main
String
args

Ans: public, static, void



===============================================================================================

3. Data Types
-----------------------------------------------------------------------------------
In java, every variable and every expression has some type. Each and every data type is clearly defined. Every assignment should be checked by compiler for type compatibilty.
Because of above reasons, we can conclude Java language is strongly type programming language.

Java is not considered as pure Object Oriented Programming Language because several OOP features are not satisfied by Java (like operator overloading, and multiple inheritance).
Moreover, we are depending on primitive data types which are non objects.

primitive data types
------------------------
8 primitive data types.
Data types which talks about numbers are called Numeric data types.
Numeric data types have 2 categories: integers and with decimal points
Numeric data types which only talks about integers are called Integral Data types. byte, short int
Numeric data types which talks about number with decimal values are called Floating Data types. float, double
Data types which do not talks about numbers are called Non Numeric data types.
Non-numeric data types are: boolean, char

Numeric Data types(except boolean and char) are considered as signed data types because we can represent both positive and negative numbers.
The first bit in numeric data type is signed bit which stores whether number is positive or negative. This signed bit is known as MSB (most significant bit) 0 means positive
and 1 means negative, remaining bits represent values.

1. byte
-----------
Size: 1 byte = 8 bits

max value: as first bit is considered as MSB we are left with 7 bits:
MSB 1   1   1   1   1   1   1
    2^6 2^5 2^4 2^3 2^2 2^1 2^0

Adding above: 64+32+16+8+4+2+1 = 127
so max value is 127

min value is -128. This is calculated using 2's complement with 7 bits.

Range: -128 to 127

positive number will be represented directly in memory whereas negative number will be represented in 2's complemented form.

byte b = 128;
Compile Time Error:
error: incompatible types: possible lossy conversion from int to byte

byte b = 12.3;
Compile Time Error:
error: incompatible types: possible lossy conversion from double to byte

byte b = true;
Compile Time Error:
error: incompatible types: boolean cannot be converted to byte

byte b = "duega";
Compile Time Error:
error: incompatible types: String cannot be converted to byte

Byte is the best choice if we want to handle the data in terms of streams either from the file or from the network (File supported form or Network supported form is Byte)

2. short
----------------
Size: 2 bytes
Range: -2^15 to 2^15 - 1
       -32768 to 32767
Rarely used data type in java

Short data type is best suitable for 16 bit processors like 8085 but these processors are completely outdated and hence corresponding short data type is also outdated data type.

3. int
---------
The most commonly used data type in java is int data type.
size: 4 bytes (32 bits)
Range: -2^31 to 2^31 - 1
       -2147483648 to 2147483647
Ex:

int x = 2147483648;
Compile Time Error:
 error: integer number too large

int x = 2147483648l;
Compile Time Error:
error: incompatible types: possible lossy conversion from long to int

int x = true;
Compile Time Error:
error: incompatible types: boolean cannot be converted to int

4. long
------------
Sometimes int may not enough to hold big values, then we should go for long type.
Ex1:
the amount of distance travelled by light in thousand days, to hold this value int is not enough. We should go for long data type.
long l = 126000 * 60 * 60 * 24 * 1000; #miles
ex2:
The number of characters present in a big file may exceed int range hence the return type of length() method is long but not int.

long l = f.length()

size: 8 bytes (64 bits)
range: -2^63 to 2^63 - 1

Note: All the above data types (byte, short, int, long) meant for representing integral values. If we want to represent floating point values then we should go for floating point data types.

Floating point data types
------------------------------

   Float                                                                        |         double
1. If we want 5 to 6 decimal places of accuracy, then we should go for float.   | if we want 15 to 16 decimal places of accuracy, then we should go for double.
2. Float follows single precision                                               | Double follows double precision
3. Size: 4 bytes                                                                | Size: 8 bytes
4. Range: -3.4 e38 to 3.4 e38                                                   | Range: -1.7 e308 to 1.7 e308

Boolean data types
------------------------
Size: Not applicable (Virtual machine dependent)
Range: Not applicable (allowed values are true or false)

ex:
boolean b = true;    valid

boolean b = 0;       invalid
CTE
error: incompatible types: int cannot be converted to boolean

boolean b = True;
CTE
error: cannot find symbol
symbol:   variable True
location: class Test

boolean b = "True";
CTE
error: incompatible types: String cannot be converted to boolean


int x = 0;
if (x){
    System.out.println("Hello");
}
else{
    System.out.println("Hi");
}

CTE
error: incompatible types: int cannot be converted to boolean

while(1){
     System.out.println("Hi");
}
CTE
error: incompatible types: int cannot be converted to boolean

char data type
-------------------
Old languages, like C/C++ are ASCII code based and the number of allowed different characters are less than or equal to 256. To represent these 256 characters, 8 bits are enough,
hence the size of char in old languages is 1 byte but Java is Unicode based and the number of different unicode characters are greater than 256 and less than or equal to 65536.
To represent these many characters, 8 bits may not be enough compulsory we should go for 16 bits. Hence the size of char in java is 2 bytes.

size: 2 bytes
range: 0-65535

--------------------------------------------------------------------------------------------------------------------------

data type       |    size       |   range                               |   wrapper class         |       default value
--------------------------------------------------------------------------------------------------------------------------
byte            |   1 byte      |   -2^7 to 2^7 -1                      |   Byte                   |0
short           |   2 bytes     |   -2^15 to 2^15 - 1                   |   Short                  |0
int             |   4 bytes     |   -2^31 to 2^31 - 1                   |   Int                    |0
long            |   8 bytes     |   -2^63 to 2^63 - 1                   |   Long                   |0
float           |   4 bytes     |   -3.4 e38 to 3.4 e38                 |   Float                  |0.0
double          |   8 bytes     |   -1.7 e308 to 1.7 e308               |   Double                 |0.0
boolean         |   NA          |   NA(allowed values are true/false)   |   Boolean                |false
char            |   2 bytes     |   0-65535                             |   Character              |0 (0 represent space)


null is default value for object reference and we cannot apply for primitives, If we are trying to use for primitive, we will get CTE incompatible_types.
Ex:
char ch = null;
CTE
incompatible types: <null> cannot be converted to char

===============================================================================================

4. Literals
----------------

A constant value which can be assigned to the variable is called literal.
int x = 10;
int - data type/ keyword
x - name of variable/ identifier
10 - constant value/literal

Integral literals
---------------------
For integral data types (byte, short, int, long) we can specify literal value in the following ways:

1. decimal literals (base 10)
---------------------------
allowed digits are: 0-9
int x = 10; 10 is decimal form
2. octal literal (base 8) (0-7)
-------------------------------
Literal value should be prefixed with zero to denote it is octal literal form
allowed digits are 0 to 7
int x = 010
3. Hexa decimal form (base 16)
----------------------
Literal value should be prefixed with 0x to denote it is octal literal form
allowed digits are: 0-9, a-f
int x = 0x10;

We can use a-f or A-F for extra digits because java is case insensitive in this case. This is one of very few areas where java is case insensitive
int x = 0X10 is also valid

These are only valid ways to specify integral literal data types.

Q. Which of these are valid?
int x = 10;
int x = 0786;
int x = 0777;
int x = 0XFace;
int x = 0XBeef;
int x = 0XBeer;

Ans:
All except:
int x = 0786;
CTE:
error: integer number too large
int x = 0XBeer;
CTE:
 error: ';' expected


class Test{
    public static void main(String []args){
        int x = 10;
        int y = 010;
        int z = 0x10;
        System.out.println(x+" "+y+" "+z);
    }
}

op:
10 8 16

Every integral literal will always be of int type by default if l/L is not added in last in literal.
Ex:
10
010
0x10
all above literals are of int type
but if we add l to them:
10l;
010l;
0x10l;
are of long type
if l/L is suffixed into literal they are of long type

Q.Which are valid?
int x = 10;
long x = 10l;
int x = 10l;
long l = 10;

Ans: All are valid except:
int x = 10l;
CTE
error: incompatible types: possible lossy conversion from long to int.


There is no direct way to specify byte and short literals explicitly but indirectly we can specify. Whenever we are assigning integral literal to the byte variable and if the value within the range of byte
then compiler treats it automatically as byte literal, similarly short literal also.
byte b = 127; valid
byte b = 10; valid
byte b = 128; error: incompatible types: possible lossy conversion from int to byte.

short s = 32767; valid
short s = 32768; error: incompatible types: possible lossy conversion from int to short.


Floating point literals
------------------------------
By default, every floating point literal is of double type and hence we cant assign directly to the float variable but we can specify floating point literal as float type by sufixing with f or F.
float f = 123.456; error: incompatible types: possible lossy conversion from double to float
float f = 123.456f; valid
float f = 123.456F; valid
double d = 123.456; valid
double d = 123.456D; valid

We can specify explicitly floating point literal as double type b y suffixing with d or D, of course this convention is not required.
double d = 123.456D; valid

Which are valid?
double d = 123.456;
double d = 0123.456;
double d = 0x123.456;

Ans:
double d = 0x123.456;
CTE
 error: malformed floating point literal

Others are valid, even double d = 0123.456; because 0 here is not considered as octal not decimal.

We can specify floating point literals only in decimal form and we cannot specify in octal and hexadecimal forms.
We can assign integral literal directly to floating point variables and that integral literal can be specified either in decimal or octal or hexadecimal forms.

double d = 0786;
invalid, CTE:
error: integer number too large
double d = 0xFace;
valid
double d = 0786.0;
valid
double d = 0xFace.0;
invalid, CTE
error: malformed floating point literal

We cannot assign floating point literals to integral types.
Ex:
double d = 10;
valid
int x = 10.0
invalid, CTE
error: incompatible types: possible lossy conversion from double to int

We can specify floating point literal even in exponential form (scientific notation)

double d = 1.2e3;
sopln(d);
valid
1200.0

float f = 1.2e3;
invalid, CTE
error: incompatible types: possible lossy conversion from double to float

float f = 1.2e3F;
valid
1200.0

Boolean literals
------------------
The only allowed values for boolean data types are true or false.

boolean b = true;
valid

boolean b = 0;
invalid, CTE
error: incompatible types: int cannot be converted to boolean

boolean b = True;
invalid, CTE
error: cannot find symbol
        boolean b = True;
                    ^
symbol:   variable True
location: class Test

boolean b = "True";
CTE
incompatible types: String cannot be converted to boolean


int x = 0;
if (x){
    System.out.println("Hello");
}
else{
    System.out.println("Hi");
}

CTE:
error: incompatible types: int cannot be converted to boolean

while(1){
    System.out.println("Hello");
}
CTE:
error: incompatible types: int cannot be converted to boolean

Char Literals
----------------------
We can specify char literal as single character within single quotes.

char ch = 'a';
valid

char ch = a;
error: cannot find symbol
        char ch = a;
                  ^
symbol:   variable a
location: class Test


char ch = "a";
error: incompatible types: String cannot be converted to char

char ch = 'ab';
CTE
Test.java:3: error: unclosed character literal
        char ch = 'ba';
                  ^
Test.java:3: error: unclosed character literal
        char ch = 'ba';
                     ^
Test.java:3: error: not a statement
        char ch = 'ba';
                    ^
3 errors

We can specify char literal as integral literal which represents unicode value of the character and that integral literal can be specified either in decimal or octal or hexadecimal form but
allowed range in 0-65535.
char ch = 97;
sopln(ch)
valid; a

char ch = 0xFace;
sopln(ch)
valid

char ch = 0777;
sopln(ch)
valid

char ch = 65535;
valid

char ch = 65536;
error: incompatible types: possible lossy conversion from int to char.

We can represent char literal in unicode representation which is nothing but '\uxxxx' where xxxx is 4 digit hexadecimal number
ex:

char ch = '\u0061';
valid, a
char ch = '\u0062';
valid, b

Every escape character is a valid char literal.
Ex:
char ch = '\n';
valid
char ch = '\t'
valid

char ch = '\m'
CTE:
Test.java:3: error: illegal escape character
        char ch = '\m';
                    ^
Test.java:3: error: unclosed character literal
        char ch = '\m';
                  ^
Test.java:3: error: unclosed character literal
        char ch = '\m';
                     ^
In Java, there are 8 escape characters are present.

\n - new line
\t - horizontal-tab
\r - carriage return
\b - backspace (delete one character)
\f - form feed
\' - single quote
\" - double quotes
\\ - back slash

Sopln("This is \' symbol");
sopln("This is \" symbol");
Sopln("This is \\ symbol");

Which of the following are valid?
char ch = 65536;
char ch = 0xBeer;
char ch = \uFace;
char ch = '\uBeef';
char ch = \m
char ch = \iface;

Ans:
char ch = 65536;
char ch = 0xBeer;
char ch = \uFace;
char ch = \m
char ch = \iface;

are invalid


String literals
--------------------
Any sequence of characters within double quotes are string literals.
String s = "durga";

1.7 version enhancements with respect to literals
-------------------------------------------------------
1. Binary literals
For integral data types, until 1.6 version, we can specify literal value in the following ways:
1. Decimal form
2. Octal form
3. Hexadecimal form

In 1.7 version onwards, we can specify literal value in Binary form also.
Allowed digits are 0 and 1.
int x = 0B1111;
Sopln(x)

OP: 15

Literal value should be prefixed with 0B or 0b
2. Usage of _ (underscore) symbol in numeric literals
--------------------------------------------------------
From 1.7 version onwards, we can use _ (underscore) symbol between digits of numeric literal
double d =  123456.789
can be written as:
double d = 1_23_456.7_8_9;
or
double d = 123_456.7_8_9;
The main advantage of this approach is readability of the code will be improved.

At the time of compilation, these underscore symbols will be removed automatically, hence after compilation the above lines will become:
double d = 1233456.789;

We can use more than one underscore symbol also between two digits.
double d = 1__2_3_4_5__6.7_8_9;
double d = 1____2__3_4_5_6.7_8_9;


We can use underscore symbol only between 2 digits, not anywhere else. If we are using anywhere else, we will get CTE.

These are invalid usage:
double d = _1_23_456.7_8_9;
double d = 1_23_456_.7_8_9;
double d = 1_23_456.7_8_9_;


Summary:

byte -> short -> int
char -> int
int -> long -> float -> double

The above conversions are always possible.

NOTE:
8 byte long value can be assigned to 4 byte float variable because both are following different memory representations internally.

float f = 10l;
sopln(f);
10.0


===============================================================================================


5. Arrays
-----------------
1. Introduction
2. Array Declaration
3. Array Creation
4. Array Initialization
5. Array Declaration, Creation and Initialization in one line
6. length vs length()
7. Anonymous Arrays
8. Array element assignments
9. Array variable assignments
-------------------------------------------------
1. Introduction
-------------------------------------------------

An array is an indexed collection of fixed number of homogenous data elements. The main advantage of array is we can represent huge number of values by using single variable
so that readability of the code will be improved.
But the main disadvantage of arrays is fixed in size i.e once we create an array there is no chance of increasing or decreasing the size based on our requirements, hence to use
arrays concept compulsory we should know the size in advance which may not be possible always.

2. Array Declaration
------------------------
One dimensional array Declaration
-------------------------------------
int[] x;
int []x;
int x[];

First one is recommended because name is clearly separated from type.

Conclusions
-----------
1. At the time of declaration we cannot specify the size otherwise we will get CTE.

int[6] x;   Invalid
int[] x;    Valid

Two Dimensional Array Declaration
-----------------------------------
int[][] x;
int [][]x;
int x[][];
int[] []x;
int[] x[];
int []x[];

All these are valid declarations.

int[] a,b;
a-> 1D array
b-> 1D array

int[] a[],b;
a -> 2D array
b -> 1D array

int[] a[], b[];
a -> 2D array
b -> 2D array

int[] []a, b;
a -> 2D array
b -> 2D array

int[] []a, b[];
a -> 2D array
b -> 3D array

int[] []a, []b;
Invalid, CTE

If we want to specify dimension before the variable, the facility is applicable only for first variable in a declaration.If we are trying to apply for remaining variables, we will get CTE.
int[] []a, []b;
Invalid, CTE

int[] []a,[]b,[]c;
Invalid CTE.

Three Dimensional Array Declaration
-----------------------------------
All are valid declarations.
int[][][] a;
int [][][]a;
int a[][][];
int[] [][]a;
int[] a[][];
int[] []a[];
int[][] []a;
int[][] a[];
int [][]a[];
int[] a[][];


3. Array Creation
------------------------
One Dimensional Array Creation
-----------------------------------
Every array in Java is an object hence we can create an array using new operator.
int[] a = new int[3];

For every array type, corresponding classes are available and these classes are part of Java language and not available to the programmer level.

int[] a = new int[3];
System.out.println(a.getClass().getName());
OP: [I

Array Type          |       Corrresponding class name
--------------------|----------------------------------
int[]               |       [I
int[][]             |       [[I
double[]            |       [D
short[]             |       [S
byte[]              |       [B
boolean[]           |       [Z

1. At the time of array creation compulsory we should define size otherwise we will get CTE.
int[] x = new int[];
Invalid, CTE.

int[] x = new int[6];
Valid

2. It is legal to have an array with size 0 in Java.
int[] x = new int[0];
Valid.

3. If we are trying to specify array size with some negative value, then we will get Run Time Exception saying: NegativeArraySizeException
int[] x = new int[-3];
RE: Exception in thread "main" java.lang.NegativeArraySizeException

4. To specify array size, the allowed data types are byte, short, char, int. If we are trying to specify any other type then we will get CTE.
int[] x = new int[10];
int[] x = new int['a'];

byte b = 20;
int[] x = new int[b];

short s = 30;
int[] x = new int[s];

int[] x = new int[10l];
error: incompatible types: possible lossy conversion from long to int
5. The maximum allowed size of array is 2147483647 which is the maximum value of int data type. If we are exceeding the value we will get CTE saying integer number too large
int[] x = new int[2147483647];
int[] x = new int[2147483648];
CTE: integer number too large

Even in the below case we may get Run Time Exception if sufficient heap memory is not available.
int[] x = new int[2147483647];
Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit
        at Test.main

Two Dimensional Array Creation
-----------------------------------
In Java,Two Dimensional Array is not implemented using matrix style. Sun people followed array of arrays approach for multi dimensional array creation.
The main advantage of this approach is memory utilization will be improved.

Ex1:
int[][] x = new int[2][];
x[0] = new int[2];
x[1] = new int[3];

Ex2:
     []                  []
[] []   []            []    []
[] [][] [][][]        [][]  [][]
To represent above structure:
int[][][] x = new int[2][][];
x[0] = new int[3][];
x[0][0] = new int[1];
x[0][1] = new int[2];
x[0][2] = new int[3];
x[1] = new int[2][2];

Which of the following are valid?
int[] a = new int[];
int[] a = new int[3];
int[][] a = new int[][];
int[][] a = new int[3][];
int[][] a = new int[][4];
int[][] a = new int[3][4];
int[][][] a = new int[3][4][5];
int[][][] a = new int[3][4][];
int[][][] a = new int[3][][5];
int[][][] a = new int[][4][5];

Ans:
int[] a = new int[3];
int[][] a = new int[3][];
int[][] a = new int[3][4];
int[][][] a = new int[3][4][5];
int[][][] a = new int[3][4][];
are only valid.

int[][][] a = new int[3][][5]; this is invalid because without defining second, you cannot define third.


Array Initialization
-----------------------------------

Once we create an array, every array element initializes with a default value.

int[] x = new int[3];
System.out.println(x);
System.out.println(x[0]);

OP:
[I@3e25a5
0

NOTE:
Whenever we are trying to print any reference variable, internally toString() method will be called which is implemented by default to return the string in the following form:
classname@hashcode_in_hexadecimalform

int[][] x = new int[3][2];
System.out.println(x);
System.out.println(x[0]);
System.out.println(x[0][0]);

OP:
[[I@3e25a4
[I@3e25a2
0


int[][] x = new int[2][];
System.out.println(x);
System.out.println(x[0]);
System.out.println(x[0][0]);

OP:
[[I@3e25a4
null
RE: NullPointerException

Note:
If we are trying to perform any operation on null, then we will get RE saying NullPointerException

Once we create an array, every array element by default initialized with default values. If we are not satisfied with default values, then we can override these values with our customized values.

int[] x = new int[3];
x[0] = 10;
x[1] = 20;
x[2] = 30;

int[] x = new int[3];
x[0] = 10;
x[1] = 20;
x[2] = 30;
x[3] = 40;
RE: ArrayIndexOutOfBoundException


int[] x = new int[3];
x[0] = 10;
x[1] = 20;
x[2] = 30;
x[-3] = 40;
RE: ArrayIndexOutOfBoundException

int[] x = new int[3];
x[0] = 10;
x[1] = 20;
x[2] = 30;
x[3.2] = 40;
CTE: incompatible types: possible lossy conversion from double to int


Note:
If we are trying to access arry element with out of range exception(either positive value or negative int value) then we will get RunTimeException saying ArrayIndexOutOfBoundException.

5. Array Declaration, Creation and Initialization in one line
------------------------------------------------------------------

int[] x = new int[3];
x[0] = 10;
x[1] = 20;
x[2] = 30;

The above can be represented in single line:
int[] x = {10,20,30};

char[] ch = {'a','e','i','o','u'}
String[] s = {"A","AA","AAA"};

We can extend this shortcut for multidimensional array also.
[]          []
[10][20]    [30][40][50]

this can be represented as below:

int[][]x = {{10,20},{30,40,50}};


int[][][]x = {{{10,20,30},{40,50,60}},{{70,80}, {90,100,110}};
System.out.println(x[0][1][2]);
System.out.println(x[1][0][1]);
System.out.println(x[2][0][0]);
System.out.println(x[1][2][0]);
System.out.println(x[1][1][1]);
System.out.println(x[2][1][0]);

First represent them in memory and then you can answer easily:

[]                                  []
[]               []                 []          []
[10][20][30]    [40][50][60]        [70][80]    [90][100][110]

OP:
60
80
RE:ArrayIndexOutOfBoundException
100
RE:ArrayIndexOutOfBoundException

int[] x = {10,20,30};
If we want to use this shortcut, compulsory we should perform all activities in a single line, if we are trying to divide into multiple lines, then we will get
CTE: Illegal start of expression

int[] x;
x = {10,20,30};
CTE: Illegal start of expression

6. length vs length()
---------------------
length is a final variable applicable for arrays. length variable represents the size of the array.
Ex:
int[] x = new int[6];
Sopln(x.length())
CTE: cannot find symbol
Sopln(x.length)
OP: 6

String s = "pranjal"
Sopln(s.length);
CTE: cannot find symbol
Sopln(s.length());
OP: 7

length() is a final method applicable for String objects. length() returns number of characters present in the string

length variable applicable for arrays but not for string objects whereas length() applicable for string objects but not for arrays.

String[] s = {"A","AA","AAA"};

Sopln(s.length);
OP: 3
Sopln(s.length());
CTE: cannot find symbol
Sopln(s[0].length);
CTE: cannot find symbol
Sopln(s[0].length());
OP: 1

In multidimensional arrays, length variable represents only base size but not total size
int[][] x = new int[6][3];
Sopln(x.length);
OP: 6
Sopln(x[0].length);
OP: 3

There is no direct way to find total length of multi dimensional array but indirectly, we can find as follows:
x[0].length + x[1].length + x[2].length +.........
7. Anonymous Arrays
------------------------------------------------------------------
Sometimes we can declare an array without name, such type of nameless arrays are called Anonymous arrays.
THe main purpose of Anonymous arrays is just for instant use (one time usage).

We can create Anonymous array as follows:
new int[] {10,20,30,40};

While creating Anonymous arrays, we cannot specify the size otherwise we will get CTE.
new int[3]{10,20,30}       Invalid
new int[]{10,20,30}        Valid


We can create multidimensional Anonymous arrays also:

new int[][]{{10,20},{30,40, 50}}

Based on our requirements, we can give the name for Anonymous array, then it is no longer Anonymous.
int[] x = new int[]{10,20,30}


class Test{
    public static void main(String []args){
        sum(new int[] {10,20,30,40});
    }
    public static void sum(int[] x){
        int total = 0;
        for(int x1: x){
            total += x1;
        }
        System.out.println("The sum: "+total);
    }
}

In the above example, just to call sum method, we require an array but after completing sum method call we are not using that array any more,
hence for this one time requirement Anonymous array is the best chouce.

8. Array element assignment
--------------------------------------

int[] x = new int[5];
x[0] = 10;
x[1] = 'a';
byte b = 20;
x[2] = b;
short s = 30;
x[3] = s;
x[4] = 10l;

All are valid except last line:
x[4] = 10l;
CTE:
error: incompatible types: possible lossy conversion from long to int
Case 1:
------------
In the case of primitive type arrays, as array elements we can provide any type which can be implicitly promoted to declared type (byte, short, char, int).
In the case of float type arrays, the allowed data types are byte, short, char, int, long, float

Case 2:
--------
In the case of object type arrays, as array elements we can provide either declared type objects or its child class objects.
Object[] a = new Object[10];
a[0] = new Object();
a[1] = new String("durga");
a[2] = new Integer(10);

Number[] n = new Number[10];
n[0] = new Integer(10);
n[1] = new Double(10.5);
n[2] = new String("AAA");
CTE:
error: incompatible types: String cannot be converted to Number

Case3:
-------
For interface type arrays, as array elements its implementation class objects are allowed.
Runnable[] r = new Runnable[10];
r[0] = new Thread();
r[1] = new String("durga");
CTE:
error: incompatible types: String cannot be converted to Runnable



Array Type           |       Allowed element type
---------------------|------------------------------------------------------------------------
primitive arrays     |       any type which can be implicitly promoted to declared types.
object type arrays   |       either declared type or its child class objects
abstract type arrays |       its child class objects are allowed
interface type arrays|       implementation class objects are allowed


9.Array variable assignments
-------------------------------
Case 1:
----------
Element level promotions are not applicable at array level. For ex: Char element can be promoted to int type whereas char array cannot be promoted to int array.

int[][] x = {10,20,30,40};
char[] ch = {'a','b','c','d'};
int[] b = x;
int[] c = ch;
CTE:
incompatible types: char[] cannot be converted to int[]
int[] c = ch;

Q. Which of the following promotions will be performed automatically?
char to int
char[] to int[]
int to double
int[] to double[]
float to int
float[] to int[]
String to Object
String[] to Object[]

Ans:
char to int
int to double
String to Object
String[] to Object[]

In case of Object type arrays, child class type array can be promoted to parent class type array.
Ex:
String[] s = {"A","B","C"};
Object[] o = s
The above program is valid.

Case 2:
---------
Whenever we are assigning one array to another array, internal elements wont be copied just reference variables will be reassigned.
int[] a = {10, 20, 30, 40, 50, 60};
int[] b = {70, 80};
a = b;
b = a;
The above program is valid.
a will be {70, 80}
b will be {10, 20, 30, 40, 50, 60}

Case 3:
---------
Whenever we are assigning one array to another array, dimensions must be matched.
For ex: in the place of 1-D int array we should provide 1-D array only. If we are trying to provide any other dimension then we will get CTE.

int[][] a = new int[3][];
a[0] = new int[4][3];
CTE:
error: incompatible types: int[][] cannot be converted to int[]
a[0] = 10
CTE:
error: incompatible types: int cannot be converted to int[]

Note:
Whenever we are assigning one array to another array, both dimensions and types must be matched but sizes are not required to match.

Ex1:
class Test{
    public static void main(String []args){

        for(int i=0; i<=args.length; i++){
            System.out.println(args[i]);
        }

}
}

java Test a b c
a
b
c
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
        at Test.main


java Test a b

a
b
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
        at Test.main

java Test
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
        at Test.main

Ex2:
class Test{
    public static void main(String []args){
        String[] argh = {"x","y","z"};
        for(String s: args){
            System.out.println(s);
            }
        }
    }

java Test a b c
x
y
z

java Test a b
x
y
z


java Test
x
y
z

Q.
int[][] a = new int[4][3];
a[0] = new int[4];
a[1] = new int[2];
a = new int[3][2];

How many objects are created?
How many objects eligible for Garbage Collection?

Ans:
1.
By first line following objects are created:
[]      []      []      []
[][][]  [][][]  [][][]  [][][]
In first line we have one array, so 1 object and in next line 4 new arrays, so total 5 objects

Now, a[0] = new int[4];
a[0]
[][][][]
also, a[1] is now:
[]  []

and a = new int[3][2];
[]      []      []
[][]    [][]    [][]

total objects created = 5+1+1+4 = 11 objects
7 objects are eligible for Garbage Collection


Types of variables
---------------------
Division 1:
-------------
Based on type of value represented by a variable all variables are divided into
two types:
Primitive Variables
------------------------
Can be used to represent primitive values.
int x = 10;

Reference variables
-----------------------
Can be used to refer objects.
String s = "pranjal";
Student s = new Student();

Division 2:
--------------
Based on the position of declaration and behaviour all variables are divided into 3 types:

1. Instance Variables:
----------------------
If the value of a variable is varied from object to object, such type of variables are called instance variables.

For every object, a separate copy of instance variables will be created.

Instance variables should be declared within the class directly but outside of any method, or block or constructor.

Instance variable will be created at the time of object creation and destroyed at the time of object destruction, hence the scope of instance vaiable is
exactly same as the scope of object.

Instance vaiables will be stored in the heap memory as the part of object.

We cannot access instance variable directly from static area but we can access by using object reference, but we can access instance variables
directly from instance area.


class Test{
    int x = 10;
    public static void main(String[] args){
        Sopln(x);
        Test t = new Test();
        Sopln(t.x);
    }
    public void m1(){
        Sopln(x);
    }
}

line 1461 will give CTE
error: non-static variable x cannot be referenced from a static context
If removed, OP will be:
10

For instance variables JVM will always provide default values and we are not required to perform initialization explicitly.

class Test {
    int x;
    double d;
    boolean b;
    String s;
    psvm(..){
        Test t = new Test();
        Sopln(t1.x);
        Sopln(t1.d);
        Sopln(t1.b);
        Sopln(t1.s);
    }
}
OP:
0
0.0
false
null

Instance variable also known as object level variables or attributes.


2. Static Variables:
----------------------
If the value of a variable is not varied from object to object, then it is not recommended to declare variable as instance variable.
We have to declare such type of variables at class level by using static modifier.

In the case of instance variables, for every object a separate copy will be created but in the case of static variables a single copy
will be created at class level and shared by every object of the class.

Static variables should be declared within the class directly and they must be outside of block, method or constructor.

Static variables will be created at the time of class loading and destroyed at the time of class unloading, hence scope of static variable
is same as scope of .class file.

Whenever we execute command:
java Test
Following activities will happen:
1. Start the JVM
2. Create and start the main thread.
3. Locate Test.class file
4. Load Test.class file
5. Execute main() method
6. Unload Test.class file.
7. Terminate main thread
8. Shutdown JVM.

At step 4, static variable creation will happen.
At step 6, static variables destruction will happen.

Static variables will be stored in method area.

We can access static variable using class name or object reference, but recommended way is to access using class name.
Within same class we can directly acces the static variable, no need to call using class name.


class Test{
    static int x = 10;
    psvm(..){
        Test t = new Test();
        Sopln(t.x);
        Sopln(Test.x);

    }
}

We can access static variables directly from both, instance and static areas.

class Test{
    static int x = 10;
    psvm(..){
        Sopln(x);
    }
    public void m1(){
        Sopln(x);
    }
}

For static variables, JVM will provide default values and we are not required to perform initialization explicitly.
class Test{
    static int x;
    static double d;
    static String s;
    psvm(..){
        Sopln(x);
        Sopln(d);
        Sopln(s);
    }
}

OP:
0
0.0
null


Static variables are also known as class level variables or fields.



class Test{
    static int x = 10;
    int y = 20;
    psvm(..){
        Test t1 = new Test();
        t1.x = 888;
        t1.y = 999;
        Test t2 = new Test();
        Sopln(t2.x+"..."+t2.y);
    }
}

At the time of class loading:
x = 10
t1 object created:
so y = 20
t1.x = 888
t1.y = 999
now t2 object created,
t2.x = 888
t2.y = 20

OP:
888...20

3. Local Variables:
----------------------

Sometimes to meet the temporary requirements of programmer, we can declare variables inside a method or block or constructor, such type
of variables are called local variables or temporary variables or stack variables (because stored in stack memory) or automatic variables.

The local variable will be created while executing the block in which we declared it. Once block executions completes local variable will be destroyed.
Hence the scope of local variable is the block in which we declared it.

When thread access these local variables, each thread will have their own local variable so local variables are thread safe.

class Test{
    psvm(..){
        int i = 0;
        for(int j=0; j<3; j++){
            i=i+j;
        }
        Sopln(i+"..."+j);
    }
}
CTE:
cannot find symbol

class Test{
    psvm(..){
        try{
            int j = Integer.parseInt("ten");
        }
        catch(NumberFormatException e){
            j=10;
        }
        Sopln(j);
    }
}

CTE:
cannot find symbol

For local variables, JVM wont provide default values. Compulsory we should perform initialization explicitly before using that variable ie if we are not using
then its not required to perform initialization.

class Test{
    psvm(..){
        int x;
        Sopln("Hello");
    }
}
OP: Hello

class Test{
    psvm(..){
        int x;
        Sopln(x);
    }
}
CTE:
variable x might not have been initialized

class Test{
    psvm(String[] args){
        int x;
        if args.length > 0{
            x = 10;
        }
        Sopln(x);
    }
}
CTE:
variable x might not have been initialized


class Test{
    psvm(String[] args){
        int x;
        if args.length > 0{
            x = 10;
        }
        else{
            x = 20;
        }
        Sopln(x);
    }
}
java Test a b
OP: 10
java Test
OP: 20

Note:
1. It is not recommended to perform initialization for local variables inside logical blocks because there is no guarantee for the execution of these blocks
always at run time..
2. It is highly recommended to perform initialization  for local variables at the time of declaration atleast with the default values.


The only applicable modifier for local variables is final. By mistake if we are trying to apply any other modifier, then we will get CTE.

class Test{
    psvm(..){
        public int x = 30;
        protected int x = 30;
        private int x = 30;
        static int x = 30;
        transient int x = 30;
        volatile int x = 30;
    }
}
All lines will give CTE saying:
illegal start of expression
only valid program is:


class Test{
    psvm(){
        final int x = 30;
    }
}


NOTE:
If we are not declaring a variable with any modifier then by default it is default but this rule is only applicable for instance and static variables,
not for local variables.

Conclusions:
For instance and static variables, JVM will provide default values and we are not required to perform initialization explicitly but for local
variables, JVM wont provide default values, compulsory we should perform initialization explicitly before using that variable.

Instance and static variables can be accessed by multiple threads simultaneously and hence these are not thread safe but in case of local variables for
every thread a separate copy will be created and hence local variables are thread safe.

Types of variables      |   Is thread safe
instance variable       | no
static variable         | yes
local variable          | yes


Every variable in java should be either instance or static or local.
Every variable in Java should be either primitive or reference.
Hence, various possible combinations of variables in Java are:
instance primitive
instance reference
static primitive
static reference
local primitive
local reference



class Test{
    int x = 10;
    static String s = "pranjal";
    psvm(..){
        int[] y = new int[3];
    }
}

x is instance primitive
s is static reference
y is local reference

Uninitialized arrays
----------------------------

Instance level
------------------
class Test{
    int[] x;
    psvm(..){
        Test t = new Test();
        Sopln(t.x);
        Sopln(t.x[0]);
    }
}
OP:
null
RE: NullPointerException


class Test{
    int[] x = new int[3];
    psvm(..){
        Test t = new Test();
        Sopln(t.x);
        Sopln(t.x[0]);
    }
}

OP:
[I@3e2qw
0


Static level
------------------

class Test{
    static int[] x;
    psvm(..){
        Sopln(x);
        Sopln(x[0]);
    }
}
OP:
null
RE: NPE


class Test{
    static int[] x = new int[3];
    psvm(..){
        Sopln(x);
        Sopln(x[0]);
    }
}
OP:
[I@3e25a2
0

Local level
------------
class Test{
    psvm(..){
        int[] x;
        Sopln(x);
        Sopln(x[0]);
    }
}
CTE: variable x might not have been initialized


class Test{
    psvm(..){
        int[] x = new int[3];
        Sopln(x);
        Sopln(x[0]);
    }
}
OP:
[I@32wsq2
0


Once we creates an array every array element by default initializes with default values irrespective of whether it is instance or static or local array.

===============================================================================================

7. var-arg methods
--------------------
Until 1.4V, we cant decalre method with variable number of arguments. If there is a change in number of arguments, compulsory we should go for
new methods. It increases length of the code and reduces readability. To overcome this problem, Sun introduced var-arg methods in 1.5V.
According to this, we can take variable number of arguments, such type of methods are called var-arg methods.

We can declare var-arg method as follows:
m1(int... x)
We can call this method using any number of args including 0.

m1();
m1(10);
m1(10,20);
m1(10,20,30);

class Test{
    public static void m1(int... x){
        Sopln("var arg method");
    }
    psvm(..){
        m1();
        m1(10);
        m1(10,20);
        m1(10,20,30);
    }
}

OP:
var-arg method
var-arg method
var-arg method
var-arg method


Internally var-arg parameter will be converted into 1-D array, hence within var-arg method, we can differentiate value by using index.

class Test{
    psvm(){
        sum();
        sum(10,20);
        sum(10,20,30);
        sum(10,20,30,40);
    }


public static void sum(int... x){
    int total = 0;
    for(int x1:x){
        total+=x1;
    }
    Sopln("The sum is: "+total);
}

}

The sum is:0
The sum is:30
The sum is:60
The sum is:100

Which of following are valid var-arg method declarations?
m1(int...x)
m1(int ...x)
m1(int... x)
m1(int x...)
m1(int. ..x)
m1(int .x..)

Ans:
Valid methods are:
m1(int...x)
m1(int ...x)
m1(int... x)

Case 2:
--------

We can mix var-arg parameter with normal parameter.
m1(int x, int... y);
m1(String s, double... y)

Both of above are valid.

Case 3:
-----------
If we mix normal parameter with var-arg parameter, then var-arg parameter should be last parameter.
m1(double...d, char ch);        Invalid
m1(char ch, double... d);       Valid

Case 4:
---------
Inside var-arg method we can take only one var-arg parameter, and we cannot take more than one var-arg parameter.
m1(int... x, double... d); this is invalid


Case5:
-----------
Inside a class we cannot declare var-arg method and corresponding 1-D array method simultaneously otherwise,
we will get CTE.

class Test{
public static void m1(int... x){
    Sopln("int...");
}
public static void m1(int[] x){
    Sopln("int[]");
}

}

CTE:
cannot declare both m1(int[]) and m1(int...) in Test

Case 6:
---------
In general, var-arg method will get least priority. If no other method matched then only var-arg method will get chance.
It is exactly default case inside switch.

class Test{
public static void m1(int... x){
    Sopln("var-arg method");
}
public static void m1(int x){
    Sopln("General method");
}
psvm(){
    m1();
    m1(10,20);
    m1(10);
}
OP:
var-arg method
var-arg method
General method

Equivalence between var-arg parameter and 1-D array
------------------------------------------------------
Wherever 1-D array is present, we can replace with var-arg method
m1(int[] x) => m1(int... x)

Ex:
main(String[] args) => main(String... args)

Note:
-------
We can call this method by passsing a group of int values and x will become 1-D array.
m1(int.. x) => int[] x
m1(String... x) => String[] x

We can call this method by passing a group of 1-D int arrays and x will become 2D int array.
m1(int[]... x) => int[][] x
m1(int[][]... x) => int[][][]x

class Test{
    psvm(){
        int[] a = {10,20,30};
        int[]b = {40,50,60};
        m1(a, b);
    }
    public static void m1(int[]... x){
        for(int[] x1: x){
            Sopln(x1[0]);
        }
    }
}

OP:
10
40


===============================================================================================

8. main methods
-----------------

Whether class contains main method or not and whether main method is declared According to requirement or not,
these things wont be checked by compiler. At runtime, JVM is reponsible to check these things. If JVM unable to find main method,
then we will get RE saying: NoSuchMethodError: main


At runtime, JVM always searches for main method with following prototype:
public static void main(String[] args)

main method is public so it can be called by JVM anywhere
main method is static so without existing object also, JVM will be able to call this method
main method returns void because it wont return anything to JVM
name is main method because thats how it is configured in JVM
String[] args - command line arguments

The above syntax is very strict and if we perform any change then we will get runtime exception saying NoSuchMethodError: main

Even though above syntax is very strict, following changes are acceptable:
1. Instead of public static, we can take static public ie order of modifiers is not important.
2. We can declare String array in any form.  main(String[] args) or main(String args[]) or main(String []args)
3. instead of args we can use any valid java identifier like main(String[] pranjal)
4. We can replace String[] with var args parameter.   main(String... args)


We can declare main method with following modifiers:
final
synchronized
strictfp
Ex:
class Test{
    static final synchronized strictfp public void main(String... pranjal){
        System.out.println("Pranjal");
    }
}
Valid main method


Q.Which of the following main method declarations are valid?
public static void main(String args)
public static void Main(String[] args)
public void main(String[] args)
public static int main(String[] args)
final synchronized strictfp public void main(String[] args)
final synchronized strictfp public static void main(String[] args)
public static void main(String... args)

Ans:
final synchronized strictfp public static void main(String[] args)
public static void main(String... args)
are only valid

Q. In which of the above cases we will get Compile Time Error?
Ans: There is no case where we will get CTE but except last 2 in all cases we will get RunTimeException.

Case1:
-------
Overloading of main method is possible but JVM will always call String[] argument main method only. The other overloaded method we have to call explicitly like
normal method call
class Test{
    public static void main(String[] args){
        System.out.println("String[]");
    }
    public static void main(int[] args){
        System.out.println("int[]");
    }
}
Above is overloaded method
OP:
String[]

Case 2:
---------
class P{
    public static void main(String[] args){
        Sopln("parent main");
    }
}
class C extends P {

}

The above program is saved as P.java

javac P.java
2 classes will be created:
P.class C.class

java P
OP: parent main
java C
OP: parent main

inheritance concept applicable for main method hence while executing child classes, if child doesnt contain main method then parent class main method
will be executed.



The below program is example of method hiding not method overriding.

class P{
    public static void main(String[] args){
        Sopln("parent main");
    }
}
class C extends P {
    public static void main(String[] args){
        Sopln("child main");
    }
}

The above program is saved as P.java
javac P.java
2 classes will be created:
P.class C.class

java P
OP: parent main
java C
OP: child main

It seems overriding concept for above, but it is not method overriding and it is method hiding
NOTE:
For main method, inheritance and overloading concepts are applicable, but overriding concept is not applicable. Instead of overriding, method hiding is applicable.


Lets suppose below class we have:
class Test{

}

1.6 V                                               1.7V
------------------------------------------------------------------------------------------------
javac Test.java                                     javac Test.java
above valid                                         above valid
java Test                                           java Test
RE: NoSuchMethodError:main                          Error:main method not found in class Test, please define main method as: public static void main(String[] args)



Lets suppose below class we have:
class Test{
    static{
        Sopln("Static block");
    }
}

1.6 V                                               1.7V
------------------------------------------------------------------------------------------------
javac Test.java                                     javac Test.java
above valid                                         above valid
java Test                                           java Test
OP:                                                 OP:
Static block                                        Error:main method not found in class Test, please define main method as: public static void main(String[] args)
RE: NoSuchMethodError:main



Lets suppose below class we have:
class Test{
    static{
        Sopln("Static block");
        System.exit(0);
    }
}

1.6 V                                               1.7V
------------------------------------------------------------------------------------------------
javac Test.java                                     javac Test.java
above valid                                         above valid
java Test                                           java Test
OP:                                                 OP:
Static block                                        Error:main method not found in class Test, please define main method as: public static void main(String[] args)





Lets suppose below class we have:
class Test{
    static{
        Sopln("Static block");
    }
    psvm(String[] args){
        Sopln("main method");
    }
}

1.6 V                                               1.7V
------------------------------------------------------------------------------------------------
javac Test.java                                     javac Test.java
above valid                                         above valid
java Test                                           java Test
OP:                                                 OP:
Static block                                        Static block
main method                                         main method


In 1.6V of the flow:
Identification of static block
Execute static block and static variable assignments
Check for main method.
If available, execute main method else raise RE: NoSuchMethodError: main

In 1.7V of the flow:
Check for main method.
If available, then identification of static block and then Execute static block and static variable assignments and then execute main method.
Else, raise Error:main method not found in class Test, please define main method as: public static void main(String[] args)

Q. Without writing main method, is it possible to print some statements to the console?
Ans: Yes by executing static block but it was applicable till 1.6V, from 1.7V onwards, it is impossible to print some statements to the console without writing main method.


===============================================================================================

9. command line arguments
-----------------------------
The arguments which are passing from command prompt are called command line arguments.
With these command line arguments, JVM will create an array and by passing that array as argument, JVM will call main method:
java Test a b c
args[0] => a
args[1] => b
args[2] => c

The main objective of command line arguments is we can customize behaviour of main method.

Case1:
-----

class Test{
    psvm(String[] args){
        for(int i=0; i<=args.length; i++){
            Sopln(args[i])
        }
    }
}

java A B C
OP:
A
B
C
RE: AIOBE
java A B
OP:
A
B
RE: AIOBE

